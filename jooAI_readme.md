### jooAI预计要实现什么功能？

1. 简单的查询订单功能

> **适用情况**：类似双十一这种场景，用户下了超多单.....  但是懒得去看自己买了什么，这时就直接问客服
>
> eg：
>
> user：我买了什么？目前订单处于什么状态
>
> ai：列出所有的订单，问你要查询的是哪个？
>
> user：所有/单独几个
>
> ai：给出所有或者指定商品的状态
>
> **实现**：查数据库，返回日志（是否需要简单推理？）

2. 推荐商品

> **适用情况：**秒杀商品较多，品类超多，用户需要送礼要推荐，或者用户指定某种品类
>
> eg：
>
> user：我需要给我一个女性朋友送礼物，你有什么推荐的吗？
>
> ai：朋友性格？是需要生活用品还是工作需要？
>
> user：朋友性格很开朗
>
> ai：。。。。
>
> **实现：**推理，分析所有商品。。。。

ChatGPT

## 🧱 从“小客服”到“智能 Agent”的升级路线

可以想成 4 个层级：

1. **L0：纯 Chat（你已经有了）**
    DeepSeek + Prompt，能聊天、能回答简单问题。
2. **L1：工具增强（你刚说的查 DB 那种，其实就是 L1）**
   - 根据关键词 / 规则判断是「订单查询」「商品推荐」「闲聊」
   - 需要数据就：Java 代码自己调用 MySQL / 订单服务 → 拼进 Prompt
      这算是「**Prompt + Tool**」，但还称不上“Agent”。
3. **L2：RAG 知识库（正式引入向量检索）**
   - 把 FAQ、退货规则、优惠政策、活动玩法整理成文档 → 向量化 → 存 VectorStore
   - 问规则类问题时：先 RAG 检索，再 Prompt 生成
      这里开始可以说你有一个「**RAG 子系统**」。
4. **L3：Agent 编排：RAG + Tools + Planner** ✅（你想要的“高级感”在这里）
   - 模型不只是回答，而是：**先规划要做什么，再调用工具/RAG，再组织答案**
   - 一次对话可能触发：订单查询 + RAG 规则解释 + 商品推荐

下面我重点讲 **L2 + L3 怎么设计**，让“查订单 + 推荐商品”不只是 if-else，而是一个有结构的 Agent 工作流。

------

## 🧠 架构升级版：三层流水线

想象一下 ai-service 里有这么三层：

1. **意图理解 & 任务规划层（LLM 驱动）**
   - 职责：分析用户这句话想干嘛 → 输出一个「结构化任务描述」
2. **检索 & 工具层（RAG + 微服务）**
   - 职责：根据任务描述去：
     - 查订单服务 / 商品服务（工具调用）
     - 查 RAG 知识库（FAQ / 规则 / 商品语义向量）
3. **答案生成层（LLM 再加工）**
   - 职责：把检索结果+用户原话，组织成自然语言答复，控制语气/结构

### 🔹 第 1 层：Intent + Tool 规划（更“Agent”的感觉）

不要你自己写 if-else，而是让 DeepSeek 先给你一个“计划”，你再执行。

比如你设计一个「TaskSpec」：

```
{
  "intent": "order_query | product_recommend | faq | chit_chat",
  "need_tools": [
    {
      "name": "order_search",
      "params": { "scope": "all" }
    }
  ],
  "need_rag": [
    {
      "kb": "faq",
      "top_k": 3
    }
  ]
}
```

**实现方式（概念）：**

- 系统 Prompt 告诉 DeepSeek：

  > “你的任务是把用户问题解析成 JSON，不要直接回答，只输出 JSON，不解释。”

- Java 里用 Spring AI：

```
TaskSpec spec = chatClient.prompt()
    .system("你是一个 planner...")
    .user("用户问题：" + question)
    .call()
    .entity(TaskSpec.class);  // 直接解析成 Java 对象
```

然后你按 `spec` 里写的：

- `intent="order_query"` → 去调用订单服务
- `need_rag` 里有 `"kb":"faq"` → 去 RAG 知识库查几段文档
- 查完之后，组织成一个「tool_results + rag_results」对象，再交给模型生成最终回答。

> 这时候，你已经不是「写 if(q.contains('订单'))」了，而是一个标准的 **“Planner + Executor” Agent 架构**。
>  简历可以写：**“基于 LLM 的任务规划（planner）+ 工具执行（executor）模式，实现 Agent 级客服能力。”**

------

### 🔹 第 2 层：RAG 真正用起来（而不是“只是查数据库”）

你有几个非常适合做 RAG 的知识域👇：

1. **FAQ & 规则库 RAG**

   - 内容：退换货规则、积分说明、优惠券使用条件、活动玩法
   - 存储：用 Spring AI 的 `EmbeddingClient + VectorStore`（Redis / PGVector）
   - 用途：
     - user：`“积分怎么用？退货要自付运费吗？”`
     - 系统：从 faq 向量库拿 3 段最相关的文档，拼进 Prompt，让 DeepSeek基于文档作答。

2. **商品语义向量库 RAG（推荐更聪明一点）**

   - 为每个商品生成一段文本描述：

     - 「类目 + 标签 + 适合人群 + 价格区间 + 简短文案」

   - 做 embedding 存到向量库

   - 当用户说：`“送给开朗的女性朋友，预算 200 左右”`

     - 先把这句话 embed → 在商品向量库里找最相近的 N 个 → 再喂给 DeepSeek：

       > “这 10 件商品是最符合 Ta 的需求的候选，请从中挑 3 件，给出推荐理由。”

   这样就不是“你自己乱写 if(category == 女士 && price<200)”，而是让向量相似度 + 模型帮你一起选。

3. **会话记忆 / 用户偏好 RAG（可选进阶）**

   - 把用户过去问过的问题、喜欢的商品、预算偏好，做成一条条 document

   - 某些场景下检索出来 → Prompt 里加一句：

     > “该用户过去偏好 xxx 品类，对价格敏感度中等，请在推荐时考虑这一点。”

------

### 🔹 第 3 层：答案生成（有模板、有风格）

最后这一步才是「DeepSeek 输出答案」，但你可以控制它的**结构和风格**：

- 订单查询场景：固定结构：

  1. 简短总结（你最近有 N 个订单）
  2. 表格式列出：商品名、时间、状态、金额
  3. 问一句还需不需要看某一个的详情

- 商品推荐场景：固定结构：

  - 【商品名】+【大致价位】+【推荐理由】+【是否正在秒杀】

  - 最后一句话鼓励点击：

    > “如果你希望我只保留 2 个备选，也可以告诉我～”

在 Prompt 里写：

```
要求：
1. 使用有序列表输出。
2. 每一条包含【商品名】【大致价位】【推荐理由】。
3. 不要编造商品，只能使用提供的列表。
```

这样你就是在实现一个有“**模板化输出 + 数据驱动**”的客服，而不是简单闲聊。

------

## 🧩 这些在架构图/简历上可以怎么描述？

你可以把 ai-service 这个项目，描述成这样一个体系：

> - 采用 Spring Boot 3 + Spring AI + DeepSeek，构建独立的智能客服微服务 `ai-service`，通过网关对外提供统一对话接口。
> - 引入 **Planner + Executor 的 Agent 架构**：由 LLM 负责意图识别与工具规划（订单查询、商品搜索、FAQ 检索等），Java 侧负责实际调用订单服务、商品服务与 RAG 知识库，并将结果回传给模型生成最终回复。
> - 基于 Spring AI 的 `EmbeddingClient + VectorStore` 实现 **RAG 知识检索**：
>   - FAQ / 退货政策 / 活动规则知识库，用于规则类问答；
>   - 商品语义向量库，用于“送礼推荐 / 个性化导购”等场景。
> - 支持多轮对话与会话上下文，将用户历史提问与偏好作为检索信号，提高推荐准确度和对话连贯性。

这就从“查数据库 + 拼日志” → 变成一个 **“RAG + Tools + Agent 编排”的 AI 子系统**，档次确实不一样。

------

如果你愿意，下一步我可以帮你直接起一个：

- `TaskSpec` 的 Java 类定义
- 一个简单的「Planner Prompt」示例
- 以及一个最小可跑通的 `ConversationService` 骨架：
  - 第一次调用 DeepSeek 得到“任务规划 JSON”
  - Java 执行订单查询 / RAG
  - 第二次调用 DeepSeek 生成最终回答

这样你就可以真正在代码里跑出一个「小 Agent」。